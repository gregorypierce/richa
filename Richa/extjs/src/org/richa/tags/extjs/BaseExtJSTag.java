package org.richa.tags.extjs;

import java.util.Iterator;
import java.util.Stack;

import org.apache.commons.jelly.JellyTagException;
import org.apache.commons.jelly.MapTagSupport;
import org.apache.commons.jelly.XMLOutput;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.richa.event.EventListeners;
import org.richa.runner.RichaRunner;
import org.richa.util.AppendingStringBuffer;
import org.xml.sax.SAXException;

/**
 * <p>
 * <code>BaseExtJSTag</code> is a DynaTag implementation which uses a Map to store
 * its attribute values in. Derived tags can then process this Map, change
 * values, add or remove attributes or perform some other form of processsing
 * pretty easily.
 * </p>
 */

public abstract class BaseExtJSTag extends MapTagSupport
{
	protected static Log log = LogFactory.getLog(BaseExtJSTag.class);
	
	public static final String NAME = "name" ;
	public static final String PARAMS = "params" ;
	public static final String ID = "id" ;
	public static final String CLASS = "class" ;
	public static final String CLIENT = "client" ;
	public static final String SERVER = "server" ;
	public static final String TEXT = "text" ;
	public static final String HIDDEN = "hidden" ;
	public static final String ACTIVE = "active" ;
	public static final String DISABLE = "disable" ;
	public static final String CONTENTURL = "contentURL" ;
	public static final String WIDTH = "width" ;
	public static final String TITLE = "title" ;
	public static final String REGION = "region" ;
	public static final String ELEMENT = "element" ;
	public static final String BORDERLAYOUT = "borderlayout" ;
	public static final String SENDDATA = "senddata" ;
	public static final String THEME = "theme" ;
	public static final String BIND = "bind" ;
	
	
	public static final String FIELD = "field" ;
	public static final String FORM = "form" ;
	public static final String PAGE = "page" ;
	public static final String NONE = "none" ;
	
	private static final String TRUE = "true" ;
	private static final String FALSE = "false" ;
	
	private static final String RICHADISPATCHEVENT = "RichaDispatchEvent" ;
	
	/**
	 * Script Buffer
	 */
	protected AppendingStringBuffer scriptBuffer ;
	
	/**
	 * EventHandler Buffer
	 */
	protected AppendingStringBuffer eventBuffer ;
	
	/**
	 * Current Active form
	 */
	protected String currentForm ;
	
	/**
	 * Current Active tabpanel name
	 */
	protected String currentTabPanelName ;
	
	/**
	 * Current Active border layout name
	 */
	protected String currentBorderLayoutName ;
	
	/**
	 * Name of the web context
	 */
	protected String webContext ;
	
	/**
	 * Javascript name that will be generated by the tag
	 */
	protected String objectName ;
	
	/**
	 * Listener Stack 
	 */
	protected Stack<String> listenerStack ;
	
	/**
	 * true indicates the engine will skip all the subelements of this tag
	 */
	protected boolean skipBody = false;
	
	/**
	 * Get the javascript object name of the tag
	 * @return
	 */
	protected String getObjectName()
	{
		return (null) ;
	}
	
	/**
	 * Get the name of the tag
	 * @return
	 */
	protected String getName()
	{
		return ((String) getAttributes().get(NAME)) ;
	}
	
	/**
	 * Get the id of the tag
	 * @return
	 */
	protected String getId()
	{
		return ((String)getAttributes().get(ID)) ;
	}
	
	/**
	 * Get the class of the tag
	 * @return
	 */
	protected String getStyle()
	{
		return ((String)getAttributes().get(CLASS)) ;
	}
	
	/**
	 * Default method for processing before the body
	 * @throws JellyTagException
	 */
	protected void beforeBody(final XMLOutput output) throws JellyTagException, SAXException
	{	
	}
	
	/**
	 * Default method for processing after the body
	 * @throws JellyTagException
	 */
	protected void afterBody(final XMLOutput output) throws JellyTagException, SAXException
	{	
	}
	
	/**
	 * Skip the subelements of the current tag
	 */
	protected void skipBody()
	{
		skipBody = true ;
	}
	
	//	 Tag interface
    //-------------------------------------------------------------------------
    public void doTag(final XMLOutput output) throws JellyTagException
    {
    	try
    	{
    		//Get the Script Buffer
    		scriptBuffer = (AppendingStringBuffer)(getContext().findVariable(RichaRunner.SCRIPTBUFFER)) ;
    		
    		//Get the Event Buffer
    		eventBuffer = (AppendingStringBuffer)(getContext().findVariable(RichaRunner.EVENTBUFFER)) ;

    		//Get the Web Context
    		webContext = (String)(getContext().findVariable(RichaRunner.WEBCONTEXT)) ;

    		//Get the current form
    		currentForm = (String)(getContext().findVariable(RichaRunner.CURRENTFORM));
    		
    		//Get the current tab panel name
    		currentTabPanelName = (String)(getContext().findVariable(RichaRunner.CURRENTTABPANELNAME)) ;
    		
    		//Get the current border layout name
    		currentBorderLayoutName = (String)(getContext().findVariable(RichaRunner.CURRENTBORDERLAYOUTNAME)) ;
    		
    		//Get the listener stack
    		listenerStack = (Stack<String>)(getContext().findVariable(RichaRunner.LISTENERSTACK)) ;
    		
	    	//Call the before 
	    	beforeBody(output);
	    	
	    	//Does the body need to be skipped
	    	if (!skipBody)
	    		invokeBody(output) ;
	    	
	    	//Call the after
	    	afterBody(output);
    	}
    	catch (Exception exp)
    	{
    		throw new JellyTagException(exp) ;
    	}
    }
 
    /**
     * Check if the value is empty
     * @param value
     * @return if it is empty
     */
    protected boolean isEmpty(String value)
    {
    	if ((value == null) || (value.trim().equals("")))
    		return true ;
    	else
    		return false ;
    }
    
    /**
     * Check if the value is numeric
     * @param value
     * @return true, if it is numeric
     */
    protected boolean isNumber(String value)
    {
    	boolean isNumber = false ;
    	if (isEmpty(value))
    		return isNumber ;
    	
    	try
    	{
    		Double.parseDouble(value) ;
    		isNumber = true ;
    	}
    	catch (NumberFormatException e)
    	{}
    	
    	return (isNumber) ;
    }
    
    /**
     * Check if the value is a boolean
     * @param value
     * @return true, if it is boolean
     */
    protected boolean isBoolean(String value)
    {
    	if (isEmpty(value))
    		return false ;
    	
    	value = value.toLowerCase() ;
    	if (value.equals(TRUE) || value.equals(FALSE))
    		return true ;
    	else
    		return false ;
    }    
    
    /**
     * Serialize all the attributes in the tag
     */
    protected void serializeAttributes()
    {
    	int i = 0;
    	
    	//Get the iterator
    	Iterator attrs = getAttributes().keySet().iterator();
    	
    	//Loop through the keys except name and serialize it
    	while (attrs.hasNext())
    	{
    		String name = (String) attrs.next() ;
    		
    		if (!excludeParam(name))
    		{
    			scriptBuffer.append("        ") ;
    			if (i > 0)	     	
    				scriptBuffer.append(",") ;
    			
    			scriptBuffer.appendln(name + ":" + serializeValue((String)getAttributes().get(name))) ;
    			i++ ;    			    	
    		}
    	}	
    }
    
    
    /**
     * Serialize all the events in the tag
     */
    protected void serializeEvents() throws JellyTagException
    {
    	//Get the iterator
    	Iterator attrs = getAttributes().keySet().iterator();
    	
    	//Loop through the keys except name and serialize it
    	while (attrs.hasNext())
    	{
    		//Is this is a server side event
    		String name = (String) attrs.next() ;
    		if (name.startsWith(SERVER))
    			serializeEvent(name,SERVER) ;
    		else if (name.startsWith(CLIENT))
    			serializeEvent(name,CLIENT) ;
    	}	
    }
    
    /**
     * Serialize an event
     */
    protected void serializeEvent(String name, String type) throws JellyTagException
    {
    	String senddata = null ;
    	String jshandler = null ;
    	String listener = getCurrentListener() ;
		if (listener == null)
			throw new JellyTagException("A listener is not defined for this tag. Please enclose this tag inside a listener tag.") ;
		
		String eventName = name.substring(type.length()).toLowerCase() ;
		String handler = (String)getAttributes().get(name) ;
		
		//Get send data if it is a server side event
		if (SERVER.equals(type))
		{
			senddata = (String)getAttributes().get(SENDDATA) ;
			if (senddata == null)
				senddata = FIELD ;
			jshandler = RICHADISPATCHEVENT ;
		}
		else
			jshandler = handler ;
		
		
		eventBuffer.appendln("    RichaBindEvent(" + getName() + ",'" + getObjectName() + "','" + eventName + "'," + jshandler + ",'" + listener + "','" + handler + "','" + senddata + "');") ;   		
    }
    /**
     * Serialize one value ;
     * @param value
     * @return
     */
    protected String serializeValue(String value)
    {
    	if (isEmpty(value))
    		return "''" ;
    	
    	if (isNumber(value))
    		return value ;
    	
    	if (isBoolean(value))
    		return value ;
    	
    	return ("'" + value + "'") ;
    }
    
    /**
     * Get the attribute value
     * @param name
     * @return value
     */
    protected String getAttribute(String name)
    {
    	return (String)getAttributes().get(name) ;
    }
    
    /**
     * Get the current form name
     * @return
     */
    protected String getCurrentFormName()
    {
    	return currentForm ;
    }
    
    /**
     * Set the current form name
     * @return
     */
    protected void setCurrentFormName(String name)
    {
    	context.setVariable(RichaRunner.CURRENTFORM, name) ;
    }
    
    /**
     * Clear the current form name
     * @return
     */
    protected void clearCurrentFormName()
    {
    	context.setVariable(RichaRunner.CURRENTFORM, null) ;
    }
    
    /**
     * Get the current tab panel name
     * @return
     */
    protected String getCurrentTabPanelName()
    {
    	return currentTabPanelName ;
    }
    
    /**
     * Set the current tab panel name
     * @return
     */
    protected void setCurrentTabPanelName(String name)
    {
    	context.setVariable(RichaRunner.CURRENTTABPANELNAME, name) ;
    }
    
    /**
     * Clear the current tab panel name
     * @return
     */
    protected void clearCurrentTabPanelName()
    {
    	context.setVariable(RichaRunner.CURRENTTABPANELNAME, null) ;
    }
    
    /**
     * Get the current border layout name
     * @return
     */
    protected String getCurrentBorderLayoutName()
    {
    	return currentBorderLayoutName ;
    }
    
    /**
     * Set the current border layout name
     * @return
     */
    protected void setCurrentBorderLayoutName(String name)
    {
    	context.setVariable(RichaRunner.CURRENTBORDERLAYOUTNAME, name) ;
    }
    
    /**
     * Clear the current border layout name
     * @return
     */
    protected void clearCurrentBorderLayoutName()
    {
    	context.setVariable(RichaRunner.CURRENTBORDERLAYOUTNAME, null) ;
    }
    
	/**
     * Serialize the creation of the the tag and its attributes
     */
    protected void serialize(boolean add)
    {   
	    scriptBuffer.appendln("    var " + getName() + " =  new " + getObjectName() + "({");
    	
	    //Serialize the attributes
    	serializeAttributes() ;
    	
    	scriptBuffer.appendln("    });") ;
    	
    	//Add it to thecurrent container
    	if (add)
    		scriptBuffer.appendln("    " + getCurrentFormName() + ".add(" + getName() + ");") ;
    }    
	/**
	 * Get the current listener
	 * @return listener name
	 */
	protected String getCurrentListener()
	{
		if (listenerStack != null)
		{
			try
			{
				String listener = listenerStack.peek() ;
				return listener ;
			}
			catch (Exception e)
			{
				return null ;
			}
		}
		else
			return null ;
	}
	

	/**
	 * Add a new listener on the stack
	 */
	protected void addListener(String name)
	{
		if (listenerStack != null)
			listenerStack.push(name) ;
	}
	
	/**
	 * Remove the current listener
	 */
	protected void removeCurrentListener()
	{
		if (listenerStack != null)
			listenerStack.pop() ;
	}
	
	/**
	 * Does this parameter need to be serialized
	 * @param name
	 */
	protected static boolean excludeParam(String name)
	{
		boolean exclude = false ;
		
		if (name.startsWith(CLIENT)) 
			exclude = true ;
		else if (name.startsWith(SERVER))
			exclude = true ;
		else if (name.equals(PARAMS))
			exclude = true ;
		else if (name.equals(SENDDATA))
			exclude = true ;
		
		return exclude ;
	}
}
